diff --git a/daemon/container_operations_unix.go b/daemon/container_operations_unix.go
index c965cbb..f455ff8 100644
--- a/daemon/container_operations_unix.go
+++ b/daemon/container_operations_unix.go
@@ -850,6 +850,48 @@ func (daemon *Daemon) releaseNetwork(container *container.Container) {
 	}
 }
 
+func (daemon *Daemon) secretsPath(container *container.Container) (string, error) {
+	return container.GetRootResourcePath("secrets")
+}
+func (daemon *Daemon) setupSecretFiles(container *container.Container) error {
+	secretsPath, err := daemon.secretsPath(container)
+	if err != nil {
+		return err
+	}
+
+	if err := os.MkdirAll(secretsPath, 0700); err != nil {
+		return err
+	}
+
+	if err := syscall.Mount("tmpfs", secretsPath, "tmpfs", uintptr(syscall.MS_NOEXEC|syscall.MS_NOSUID|syscall.MS_NODEV), label.FormatMountLabel("", container.GetMountLabel())); err != nil {
+		return fmt.Errorf("mounting secret tmpfs: %s", err)
+	}
+
+	data, err := getHostSecretData()
+	if err != nil {
+		return err
+	}
+	for _, s := range data {
+		s.SaveTo(secretsPath)
+	}
+
+	return nil
+}
+
+func (daemon *Daemon) cleanupSecrets(container *container.Container) {
+	// Now the container is running, unmount the secrets on the host
+	secretsPath, err := daemon.secretsPath(container)
+	if err != nil {
+		logrus.Errorf("%v: Secrets Path does not exist: %v", container.ID, err)
+		return
+	}
+
+	if err := syscall.Unmount(secretsPath, 0); err != nil {
+		logrus.Errorf("%v: Failed to umount %s filesystem: %v", container.ID, secretsPath, err)
+		return
+	}
+}
+
 func (daemon *Daemon) setupIpcDirs(c *container.Container) error {
 	rootUID, rootGID := daemon.GetRemappedUIDGID()
 	if !c.HasMountFor("/dev/shm") {
diff --git a/daemon/container_operations_windows.go b/daemon/container_operations_windows.go
index 37524d3..583e748 100644
--- a/daemon/container_operations_windows.go
+++ b/daemon/container_operations_windows.go
@@ -170,3 +170,10 @@ func detachMounted(path string) error {
 func killProcessDirectly(container *container.Container) error {
 	return nil
 }
+
+func (daemon *Daemon) cleanupSecrets(container *container.Container) {
+	return
+}
+func (daemon *Daemon) setupSecretFiles(container *container.Container) error {
+	return nil
+}
diff --git a/daemon/secrets.go b/daemon/secrets.go
new file mode 100644
index 0000000..dabc290
--- /dev/null
+++ b/daemon/secrets.go
@@ -0,0 +1,85 @@
+package daemon
+
+import (
+	"io/ioutil"
+	"os"
+	"path/filepath"
+)
+
+// Secret info
+type Secret struct {
+	Name      string
+	IsDir     bool
+	HostBased bool
+}
+
+// SecretData info
+type SecretData struct {
+	Name string
+	Data []byte
+}
+
+// SaveTo saves secret data to given directory
+func (s SecretData) SaveTo(dir string) error {
+	path := filepath.Join(dir, s.Name)
+	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil && !os.IsExist(err) {
+		return err
+	}
+	return ioutil.WriteFile(path, s.Data, 0755)
+}
+
+func readAll(root, prefix string) ([]SecretData, error) {
+	path := filepath.Join(root, prefix)
+
+	data := []SecretData{}
+
+	files, err := ioutil.ReadDir(path)
+	if err != nil {
+		if os.IsNotExist(err) {
+			return data, nil
+		}
+
+		return nil, err
+	}
+
+	for _, f := range files {
+		fileData, err := readFile(root, filepath.Join(prefix, f.Name()))
+		if err != nil {
+			// If the file did not exist, might be a dangling symlink
+			// Ignore the error
+			if os.IsNotExist(err) {
+				continue
+			}
+			return nil, err
+		}
+		data = append(data, fileData...)
+	}
+
+	return data, nil
+}
+
+func readFile(root, name string) ([]SecretData, error) {
+	path := filepath.Join(root, name)
+
+	s, err := os.Stat(path)
+	if err != nil {
+		return nil, err
+	}
+
+	if s.IsDir() {
+		dirData, err := readAll(root, name)
+		if err != nil {
+			return nil, err
+		}
+		return dirData, nil
+	}
+	bytes, err := ioutil.ReadFile(path)
+	if err != nil {
+		return nil, err
+	}
+	return []SecretData{{Name: name, Data: bytes}}, nil
+}
+
+func getHostSecretData() ([]SecretData, error) {
+	return readAll("/usr/share/rhel/secrets", "")
+}
diff --git a/daemon/start.go b/daemon/start.go
index 44ad1d1..90b745e 100644
--- a/daemon/start.go
+++ b/daemon/start.go
@@ -112,6 +112,12 @@ func (daemon *Daemon) containerStart(container *container.Container) (err error)
 		return err
 	}
 
+	defer daemon.cleanupSecrets(container)
+
+	if err := daemon.setupSecretFiles(container); err != nil {
+		return err
+	}
+
 	if !container.HostConfig.IpcMode.IsContainer() && !container.HostConfig.IpcMode.IsHost() {
 		if err := daemon.setupIpcDirs(container); err != nil {
 			return err
diff --git a/daemon/volumes_unix.go b/daemon/volumes_unix.go
index f0d9f2d..4e00a7c 100644
--- a/daemon/volumes_unix.go
+++ b/daemon/volumes_unix.go
@@ -18,6 +18,20 @@ import (
 // /etc/resolv.conf, and if it is not, appends it to the array of mounts.
 func (daemon *Daemon) setupMounts(container *container.Container) ([]execdriver.Mount, error) {
 	var mounts []execdriver.Mount
+
+	secretsPath, err := daemon.secretsPath(container)
+	if err != nil {
+		return nil, err
+	}
+
+	if _, err := os.Stat(secretsPath); !os.IsNotExist(err) {
+		mounts = append(mounts, execdriver.Mount{
+			Source:      secretsPath,
+			Destination: "/run/secrets",
+			Writable:    true,
+		})
+	}
+
 	for _, m := range container.MountPoints {
 		path, err := m.Setup()
 		if err != nil {
diff --git a/integration-cli/docker_cli_diff_test.go b/integration-cli/docker_cli_diff_test.go
index 4f29d36..e8e56c4 100644
--- a/integration-cli/docker_cli_diff_test.go
+++ b/integration-cli/docker_cli_diff_test.go
@@ -72,6 +72,8 @@ func (s *DockerSuite) TestDiffEnsureOnlyKmsgAndPtmx(c *check.C) {
 		"A /dev/tty":     true,
 		"A /dev/urandom": true,
 		"A /dev/zero":    true,
+		"A /run":         true, // secrets patch
+		"A /run/secrets": true, // secrets patch
 	}
 
 	for _, line := range strings.Split(out, "\n") {
